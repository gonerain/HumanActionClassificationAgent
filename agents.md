
# 🧠 Agent 模型结构与优化计划 → `agents.md`

## 当前模型结构

目前，Agent 使用的是一个基于 **单层 LSTM（Long Short-Term Memory）** 的骨架动作分类模型，用于识别基本动作如“站立”和“蹲下”。

### 模型组成：

- **输入格式**：骨架序列 `(T, J, D)`，在输入前展平为 `(T, N)`
- **主干网络**：单层 `nn.LSTM`，仅使用最后时刻隐藏状态
- **分类层**：单层 `Linear` 输出类别
- **损失函数**：`CrossEntropyLoss`
- **数据类型**：`.npz` 格式，包含 `data` 和 `label`

该模型结构简单高效，适合轻量任务，但存在以下局限：

- 缺乏深层时序建模能力
- 无法感知全局上下文（非双向）
- 无注意力机制，不能聚焦关键帧
- 骨架空间结构未显式建模

---

## 模型优化路线图

我们计划分阶段优化模型结构，提升 Agent 在复杂场景下的识别精度、稳定性与可扩展性。

### 🥇 第一阶段：改进时序建模（短期目标）

- 将 LSTM 升级为 **BiLSTM**（双向建模）
- 引入 **注意力机制**，用于聚焦关键帧信息
- 优化输入处理流程，保留时序结构而非直接展平

### 🥈 第二阶段：增强输入特征（中期目标）

- 引入高阶骨架特征：
  - 关节速度、加速度（坐标差分）
  - 姿态角度、骨架中心化处理
- 数据归一化与增强，提升模型泛化能力

### 🥉 第三阶段：结构化空间建模（中长期）

- 使用 **图卷积网络（GCN）** 或 **ST-GCN**
- 将人体骨架建模为图结构，提升关节之间结构建模能力
- 引入空间注意力机制识别关键关节

### 🏁 第四阶段：系统级 Agent 能力扩展（远期）

- 接入 **Transformer 编码器**，全局建模时序信息
- 多 Agent 协作结构设计（如：识别 + 推理 + 意图识别模块）
- 引入多模态输入（如视频帧、深度图、语音辅助）

---

## 🧩 场景级人员在岗检测逻辑

### 背景需求

在真实工地或场所中：

- 有时是多人合作作业；
- 有时工人暂时离开又返回；
- 视觉跟踪中可能出现 ID 切换、误识别或短暂消失；
- 任务流程可能长达几分钟，不能因短时异常中断判断。

因此，我们采用**场景级任务状态管理器**（ScenePresenceManager）代替单人单帧判定。

---

### 状态机设计

每个目标（由 YOLO 分配 ID）对应一个子状态机，其状态为：

- `inactive`：不在区域或未进入流程；
- `pending`：刚进入区域，等待确认；
- `active`：处于工作区域、执行任务；
- `paused`：短时离开，但仍保留状态；
- `finished`：完整流程结束。

状态转移基于连续帧统计，如：

- 连续 15 帧在区域 → `active`；
- 离开区域 ≤30 帧 → `paused`，否则归为 `inactive`；
- 总工作时长超 2 分钟（帧数）或其他条件 → `finished`。

---

### 场景级判定逻辑

使用一个聚合管理器 `ScenePresenceManager` 实时维护全体 ID 的状态：

- 只要任一 ID 状态为 `active`，即视为“有人在岗”；
- 可容忍 ID 切换（误识别、新人）；
- 可记录整个任务段时间，支持“无人时报警”。

状态判定函数：

```python
def is_scene_active():
    return len(active_worker_ids) > 0
```

---

### 程序鲁棒性设计：可能漏洞与防御策略

| 漏洞类型 | 描述 | 防御策略 |
|----------|------|----------|
| **ID 跳变** | 视觉跟踪 ID 变化 | 状态 `paused` 保留一段时间，避免误断 |
| **短时遮挡消失** | 人体被遮挡，未检测到 | 允许 ID 短暂缺席再激活 |
| **短暂进出区域反复切换** | 人刚进入或靠近边缘反复进出 | 使用多帧稳定窗口（如15帧）判定 |
| **多人交替作业** | 多人轮换进入区域 | 聚合 `active` 状态的 ID 数量判断 |
| **持续作业不退出区域** | 没有流程明确终止点 | 使用累计帧数自动触发 `finished` 状态 |
| **误检测为人或幽灵框** | 检测器误报 | 增加置信度筛选 / 使用动作识别联合判断 |
| **帧率变化或视频跳帧** | 时间计算失准 | 使用时间戳代替帧号做状态超时判断 |

---

### 可视化与调试建议

- 每个 ID 画出状态色标（绿=active，黄=pending，红=paused）；
- 场景状态栏：“当前状态：🟢 有人在岗”或“🔴 无人在岗”；
- 输出事件日志：如“ID 3 开始作业 12:03:18”；
- 可拓展为报警器（持续无人超时触发提示）。

---

## 小结（更新后）

Agent 系统正从**单目标时序识别模型**，逐步扩展为具备：

- 多人识别追踪能力；
- 区域行为判定；
- 场景级任务管理逻辑；
- 对真实环境中的视觉不确定性具备较强鲁棒性。

目标是构建具备 **长时任务理解、多目标跟踪、动态容错调度能力** 的智能 Agent 框架。

## 🧱 后端系统架构设计（新增）

### 🎯 系统目标

- 实时识别是否有工人在作业区域；
- 结合当前钢卷状态判断是否合理；
- 向前端实时推送状态，支持报表生成。

---

### 📦 系统模块划分

```
            +----------------------+
            |   二级系统接口层     |
            | (钢卷状态获取模块)    |
            +----------+-----------+
                       |
           +-----------+------------------+
           |                              |
           v                              v
+----------------------+      +------------------------+
|  推理接入服务         |      |  卷状态获取服务（占位） |
|  - /inference/report |      |  - get_current_status  |
+----------+-----------+      +------------------------+
           |                               
           v
   +---------------------+
   | 状态判定与规则判断 |
   +---------------------+
           |
    +------+------+
    |             |
+-----------+   +----------------+
| WebSocket |   | 报表数据库记录 |
| /status   |   | PostgreSQL/CSV |
+-----------+   +----------------+
        |
        v
    +---------+
    | 前端页面 |
    +---------+
```

---

### 🧠 状态判定逻辑（基础规则）

用当前卷状态 + 在岗情况判断：

```python
if current_roll_status == "empty" and detected_active_ids:
    alert("有人进入空卷区域")

if current_roll_status == "ready" and not detected_active_ids:
    alert("当前应作业但无人")
```

---

## ⚙️ 二级系统占位逻辑

暂时使用固定钢卷状态代替真实获取，后续用数据库或API替换：

```python
def get_current_roll_status() -> str:
    # TODO: 替换为真实接口，如 MES / PLC / HTTP
    return "ready"  # 可选值："empty", "ready", "working", "done"
```

---

## ✅ 日志记录策略（状态变更）

- 每个 ID 状态变更才写入日志；
- 日志格式（CSV）：

```
timestamp,frame_id,id,prev_status,status,in_zone,total_active_frames,bbox
2025-08-04 15:04:12,1234,3,pending,active,True,28,(210,150,300,400)
```

---

## 🧰 实时架构关键处理方式：跳帧处理

- 使用线程采集最新帧，推理线程只处理最新帧；
- 永不堆积，确保实时性；
- 示例：

```python
# 摄像头线程
while cap.isOpened():
    ret, frame = cap.read()
    if ret:
        latest_frame = frame

# 推理线程
while True:
    if latest_frame is not None:
        process(latest_frame.copy())
```

---

## 📝 小结

本系统后端支持以下特性：

- 模块化设计，推理、判断、状态、日志分离；
- 与二级系统解耦，便于后期对接 PLC / MES；
- 可扩展支持前端 WebSocket 实时可视；
- 已考虑推理帧率慢于采集速率问题，采用跳帧处理；
- 状态判定清晰，支持后期规则扩展与作业追溯。